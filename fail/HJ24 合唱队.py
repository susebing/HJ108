# coding=utf-8
"""
题目描述
计算最少出列多少位同学，使得剩下的同学排成合唱队形

说明：
N位同学站成一排，音乐老师要请其中的(N-K)位同学出列，使得剩下的K位同学排成合唱队形。
合唱队形是指这样的一种队形：设K位同学从左到右依次编号为1，2…，K，他们的身高分别为T1，T2，…，TK，
则他们的身高满足存在i（1<=i<=K）使得T1<T2<......<Ti-1<Ti>Ti+1>......>TK。

你的任务是，已知所有N位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。

注意不允许改变队列元素的先后顺序
请注意处理多组输入输出！

输入描述:
整数N

输出描述:
最少需要几位同学出列

示例1
输入
复制
8
186 186 150 200 160 130 197 200
输出
复制
4
"""
# 来说一下我的思路，两遍最长递增子序列，
# 第一遍从左往右，
# 第二遍从右往左，
# 然后把两遍动态规划的结果相加，取最大的那个，
# 比如8  style="color: rgb(51,51,51);">186 186 150 200 160 130 197
# 200，第一遍dp的结果是 1 1 1 2 2 1 3 4，
# 第二遍dp的结果为3 3 2 3 2 1 1 1，
# 那么相加最大是5，
# 所以需要出列的同学个数就是8-5+1=4.代码如下：


# 算法：动态规划
# 用到概念：递增子序列
# 动态规划；（动态规划之最长上升子序列的引用与改进）
# 最少几个同学出列==最多几个同学留下来
# i从左边开始，求最长上升子序列inc；
# j从右边开始，求最长下降子序列dec；
# 相当于每个元素都有自己的左边最长上升子序列和右边的最长下降子序列，
# inc[i] + dec[i]相加扣除重复计算自身的1就是留下的最长合法序列；
# 最少多少个同学出列的结果就是v.size()减最长合法序列；


import bisect


def deal(l, res):
    b = [9999] * len(l)
    for i in range(len(l)):
        pos = bisect.bisect_left(b, l[i])
        res += [pos + 1]
        b[pos] = l[i]
    return res


while True:
    try:
        n = int(input())
        s = list(map(int, input().split()))
        dp1 = []
        dp2 = []
        dp1 = deal(s, dp1)
        dp2 = deal(s[::-1], dp2)[::-1]
        a = max(dp1[i] + dp2[i] for i in range(n))
        print(n - a + 1)
    except:
        break

# 方法二 思路
# 对于这道题的含义以及解题思路可能有些人不太明白，结合上面几位大佬的解释，提出一下个人见解：
# 1. 对于题目，我个人理解是所有人都已经站好位，不能再改变位置了，只能从当中去掉人组成合唱队。同时，可以考虑中间的人两边没有人的情况（比如两头的两个人，或者这个人太矮周围的人都比他高的情况），但是这种情况基本被pass掉。
# 2. 对于1楼大佬所说的最长递增子序列，我个人见解是：
# 比如题中所给出的示例：186 186 150 200 160 130 197 200，先看每个人的左边可能出现最多的人。首先如果第一个数186在中间，左边没有数，就自己一个人，所以是1；第二个数186因为左边那个人跟他一边高，没有比他矮的了，所以也是1；第三个数150，左边的人都比他高，他如果是中间的话左边也他自己一个人，所以还是1；第四个数200，因为不能换位置，所以只能留186或者150，加上自己，就是2...最后再以197为例，左边保留150,160是左边人最多的情况，再加上自己，就是3。所以每个人左边人做多的情况（加上自己）就是（186）1 1 1 2 2 1 3 4（200）。同理，看一下每个人右边可能出现最多的人，这时我们从后往前看。200在最右面，所以自己一个人，是1；197最右面没有比他矮的，自己，是1...160左边一个比他矮的，所以算上自己是2，以此类推。所以每个人右边人做多的情况（加上自己）就是（186）3 3 2 3 2 1 1 1（200）
# 3. 所以将上面两个划横线的对应相加，就可以得到自己如果是中间的那个人，可以得到的最大的合唱队人数。当然，自己加了两遍，所以得减掉一个自己。另外题目问的是最少去掉的人，所以最后的结果：
# 总人数 - 该数所在队列人数 = 需要出队的人数
# 4. 本人所编代码中最核心的部分是（以左最长递增子序列为例）
# 1
# if l[j]<l[i] and ans[j]+1>ans[i]:  ans[i]=ans[j]+1
# 代表的意思是目前的这个ans[j] + 1是否比之前得到的 ans[i] 要大(ans[i]默认是1，表示自己一个人)。假设之前ans[i] = 4,现在ans[j] +  1 = 3,那么就不需要更新。
